import { error, fail, redirect } from "@sveltejs/kit"
import type { Actions, PageServerLoad } from "./$types"
// Import Tables type if needed for stricter typing below
import type {
  Tables,
  Enums,
  TablesInsert,
} from "../../../../../../DatabaseDefinitions" // Adjusted path, added TablesInsert
import { z } from "zod" // For stricter validation

// Define a type for the combined member+profile structure
type TeamMemberWithProfile = Tables<"team_memberships"> & {
  profiles: Pick<Tables<"profiles">, "full_name" | "avatar_url"> | null
}

// --- Define assignable roles (excluding owner) ---
// Get roles from the Enums type generated by Supabase CLI
// Assuming your enum is named 'team_role'
const ASSIGNABLE_ROLES = [
  "member",
  "writer",
  "canon-editor",
  "story-lead",
  "world-architect",
  "admin",
] as const // Keep this for runtime check fallback
type AssignableRole = Extract<
  Enums<"team_role">,
  (typeof ASSIGNABLE_ROLES)[number]
>
const assignableRolesSet = new Set<string>(ASSIGNABLE_ROLES)

// --- Validation Schema ---
const emailSchema = z.string().email({ message: "Invalid email address" })

// --- Specific type for pending invites returned by load ---
// Use Pick to select only the needed fields from the full table definition
type PendingInvite = Pick<
  Tables<"team_invitations">,
  "id" | "invited_user_email" | "role" | "created_at"
>

export const load = (async ({
  locals: { supabase, supabaseServiceRole, session },
  params,
}) => {
  const { teamId } = params
  const userId = session?.user?.id

  if (!userId) {
    error(401, "Unauthorized")
  }

  // 1. Fetch team details using the RPC function
  const { data: allUserTeams, error: rpcError } = await supabase.rpc(
    "get_user_teams_with_details",
  )

  // Handle RPC errors
  if (rpcError) {
    // Check for specific auth errors raised by the function if needed
    if (rpcError.message.includes("User must be authenticated")) {
      error(401, "Unauthorized")
    }
    console.error("Error calling get_user_teams_with_details RPC:", rpcError)
    error(500, `Failed to load team details via RPC: ${rpcError.message}`)
  }

  // Find the specific team from the list of all teams the user belongs to
  const teamDataResult = allUserTeams?.find((t) => t.team_id === teamId)

  // Handle case where function returned empty set (user not member/owner)
  if (!teamDataResult) {
    error(403, "Forbidden: You do not have permission to view this team.")
    // Or 404 if you prefer "Team not found" for non-members
    // error(404, "Team not found or you lack permissions.");
  }

  // Assign the successfully fetched team data
  const team = teamDataResult as {
    team_id: string
    team_name: string
    user_role: "admin" | "member" | "owner"
    owner_id: string
  } // Rename for clarity downstream

  // Check if the current user is the owner (needed for load AND actions)
  const isOwner = team.owner_id === userId

  // 2. Fetch basic team memberships USING SERVICE ROLE
  //    This bypasses RLS for SELECTING memberships, ensuring all members are listed.
  //    Page access control is handled by the initial RPC check.
  const { data: memberships, error: membersError } = await supabaseServiceRole
    .from("team_memberships")
    .select(`role, user_id, team_id, created_at`)
    .eq("team_id", teamId)

  if (membersError) {
    console.error(
      "Error fetching team members (using Service Role):",
      membersError,
    )
    // Decide how to handle - fail, or proceed with potentially empty members
    error(500, "Failed to load team members")
  }

  // 3. Fetch profiles and combine
  let membersWithProfiles: TeamMemberWithProfile[] = []
  if (memberships && memberships.length > 0) {
    const memberUserIds = memberships.map((m) => m.user_id)
    const { data: profilesData, error: profilesError } =
      await supabaseServiceRole
        .from("profiles")
        .select(`id, full_name, avatar_url`)
        .in("id", memberUserIds)

    if (profilesError) {
      console.error(
        "Error fetching member profiles (using Service Role):",
        profilesError,
      )
      membersWithProfiles = memberships.map((m) => ({ ...m, profiles: null }))
    } else {
      const profilesMap = new Map(
        profilesData.map((p) => [
          p.id,
          { full_name: p.full_name, avatar_url: p.avatar_url },
        ]),
      )
      membersWithProfiles = memberships.map((m) => ({
        ...m,
        profiles: profilesMap.get(m.user_id) ?? null,
      }))
    }
  }

  // 4. Fetch team projects
  // const { data: projects, error: projectsError } = await supabase
  //   .from("projects")
  //   .select(`id, name`)
  //   .eq("owner_team_id", teamId)

  // if (projectsError) {
  //   console.error("Error fetching team projects:", projectsError)
  //   // Proceed, projects might be empty
  // }

  // 5. Fetch Pending Invitations (Only if owner or maybe admin in future?)
  // We only need pending invites if the user is the owner (to manage them)
  let pendingInvitations: PendingInvite[] = [] // Use the specific PendingInvite type
  if (isOwner) {
    // Select only the columns defined in PendingInvite
    const { data: invitesData, error: invitationsError } = await supabase
      .from("team_invitations")
      .select("id, invited_user_email, role, created_at") // Ensure select matches type
      .eq("team_id", teamId)
      .eq("status", "pending") // Only fetch pending ones
      .order("created_at", { ascending: false }) // Optional: order by date

    if (invitationsError) {
      console.error("Error fetching pending invitations:", invitationsError)
      // Decide how to handle this - maybe return empty array or throw?
      // For now, log and continue with empty array.
    } else {
      // Cast the result explicitly if Supabase types aren't precise enough,
      // but the select should ensure compatibility here.
      pendingInvitations = (invitesData as PendingInvite[]) ?? []
    }
  }

  return {
    team,
    members: membersWithProfiles,
    // projects: projects ?? [],
    isOwner: isOwner,
    pendingInvites: pendingInvitations,
  }
}) satisfies PageServerLoad

export const actions: Actions = {
  updateTeamName: async ({
    request,
    locals: { supabase, session },
    params,
  }) => {
    const formData = await request.formData()
    const newName = formData.get("teamName") as string
    const { teamId } = params
    const user = session?.user

    // Return the name field consistently on validation errors for this action
    const actionData = { action: "updateName", currentName: newName || null }

    if (!user) {
      return fail(401, {
        ...actionData,
        error: "Unauthorized",
        currentName: undefined,
      }) // Don't expose name on auth fail
    }

    if (
      !newName ||
      typeof newName !== "string" ||
      newName.trim().length === 0
    ) {
      return fail(400, {
        ...actionData, // Includes currentName
        error: "Team name cannot be empty",
      })
    }

    // Verify user is the owner before allowing update
    const { data: teamData, error: fetchError } = await supabase
      .from("teams")
      .select("owner_user_id")
      .eq("id", teamId)
      .single()

    // Reset currentName if the error is not about the name itself
    if (fetchError || !teamData) {
      console.error("Error fetching team for update check:", fetchError)
      return fail(404, {
        action: "updateName",
        error: "Team not found",
        currentName: undefined,
      })
    }

    if (teamData.owner_user_id !== user.id) {
      return fail(403, {
        action: "updateName",
        error: "Only the team owner can rename the team",
        currentName: undefined, // Reset currentName
      })
    }

    // Update the team name
    const { error: updateError } = await supabase
      .from("teams")
      .update({ name: newName.trim() })
      .eq("id", teamId)

    if (updateError) {
      console.error("Error updating team name:", updateError)
      return fail(500, {
        action: "updateName",
        error: "Failed to update team name",
        currentName: newName, // Keep name on server error for retry
      })
    }

    // Success case does not need currentName
    return {
      action: "updateName",
      success: true,
      message: "Team name updated successfully.",
    }
  },

  deleteTeam: async ({ locals: { supabase, session }, params }) => {
    const { teamId } = params
    const user = session?.user
    const actionData = { action: "deleteTeam" }

    if (!user) {
      return fail(401, { ...actionData, error: "Unauthorized" })
    }

    // Verify user is the owner before allowing delete
    const { data: teamData, error: fetchError } = await supabase
      .from("teams")
      .select("owner_user_id")
      .eq("id", teamId)
      .single()

    if (fetchError) {
      console.error("Error fetching team for deletion check:", fetchError)
      return fail(500, {
        ...actionData,
        error: "Could not verify team ownership.",
      })
    }
    if (!teamData) {
      return fail(404, { ...actionData, error: "Team not found" })
    }
    if (teamData.owner_user_id !== user.id) {
      return fail(403, {
        ...actionData,
        error: "Only the team owner can delete the team",
      })
    }

    // --- Deletion Logic ---
    // Ensure all related data is handled (e.g., ON DELETE CASCADE or manual cleanup)

    // 1. Delete pending invitations (optional, cascade might handle it)
    // const { error: inviteDeleteError } = await supabase
    //  .from('team_invitations')
    //  .delete()
    //  .eq('team_id', teamId);
    // if (inviteDeleteError) { /* handle error */ }

    // 2. Delete memberships (optional, cascade might handle it)
    // const { error: memberDeleteError } = await supabase
    //   .from('team_memberships')
    //   .delete()
    //   .eq('team_id', teamId);
    // if (memberDeleteError) { /* handle error */ }

    // 3. Handle projects (delete or reassign if FK restricts team deletion)
    // const { count: projectCount, error: projectCheckError } = await supabase
    //   .from("projects")
    //   .select("id", { count: "exact", head: true })
    //   .eq("owner_team_id", teamId)

    // if (projectCheckError) {
    //   console.error(
    //     "Error checking for projects before team delete:",
    //     projectCheckError,
    //   )
    //   return fail(500, {
    //     ...actionData,
    //     error: "Could not verify associated projects.",
    //   })
    // }

    // if (projectCount && projectCount > 0) {
    //   return fail(409, {
    //     // 409 Conflict
    //     ...actionData,
    //     error: `Cannot delete team. ${projectCount} project(s) are still associated with it. Please remove or reassign them first.`,
    //   })
    // }

    // 4. Delete the team itself
    const { error: deleteError } = await supabase
      .from("teams")
      .delete()
      .eq("id", teamId)

    if (deleteError) {
      console.error("Error deleting team:", deleteError)
      // Provide a more specific message if it's a foreign key violation
      // (Might be caught by the project check above now, but keep as fallback)
      if (deleteError.code === "23503") {
        return fail(409, {
          ...actionData,
          error:
            "Cannot delete team. Ensure all associated items (like projects) are removed or reassigned first.",
        })
      }
      return fail(500, { ...actionData, error: "Failed to delete team." })
    }

    // Redirect to a safe page after deletion
    redirect(303, "/account")
  },

  removeMember: async ({ request, locals: { supabase, session }, params }) => {
    const { teamId } = params
    const user = session?.user
    const formData = await request.formData()
    const memberUserId = formData.get("memberUserId") as string

    // Base action data for returns
    const baseActionData = { action: "removeMember" as const }

    // 1. Authentication & Basic Validation
    if (!user) {
      return fail(401, { ...baseActionData, error: "Unauthorized" })
    }
    if (!memberUserId) {
      // Add failedUserId: null for consistency if needed by client checks, otherwise omit
      return fail(400, { ...baseActionData, error: "Member User ID missing." })
    }

    // Action data specific to this potential failure point
    const actionDataWithError = {
      ...baseActionData,
      failedUserId: memberUserId,
    }

    // 2. Authorization: Verify caller is the team owner
    //    (RLS also enforces this, but belt-and-suspenders is good)
    const { data: teamData, error: teamFetchError } = await supabase
      .from("teams")
      .select("owner_user_id")
      .eq("id", teamId)
      .single()

    if (teamFetchError || !teamData) {
      console.error(
        "Error fetching team for remove member check:",
        teamFetchError,
      )
      // Omit failedUserId here as it's not specific to a user interaction failure
      return fail(404, {
        ...baseActionData,
        error: "Team not found or could not verify ownership.",
      })
    }

    if (teamData.owner_user_id !== user.id) {
      return fail(403, {
        ...actionDataWithError,
        error: "Only the team owner can remove members.",
      })
    }

    // 3. Prevent owner from removing themselves (RLS also prevents this)
    if (memberUserId === user.id || memberUserId === teamData.owner_user_id) {
      return fail(400, {
        ...actionDataWithError,
        error: "Team owner cannot be removed.",
      })
    }

    // 4. Database Operation: Delete the membership
    const { error: deleteError } = await supabase
      .from("team_memberships")
      .delete()
      .match({ team_id: teamId, user_id: memberUserId })

    if (deleteError) {
      console.error("Error removing team member:", deleteError)
      return fail(500, {
        ...actionDataWithError,
        error: "Failed to remove member.",
      })
    }

    // 5. Success: No specific data needed, enhance callback will invalidate
    //    Returning a success object is good practice though.
    return { ...baseActionData, success: true, removedUserId: memberUserId }
    // SvelteKit forms + enhance + invalidateAll will handle the UI update.
  },

  changeMemberRole: async ({
    request,
    locals: { supabase, session },
    params,
  }) => {
    const { teamId } = params
    const user = session?.user
    const formData = await request.formData()
    const memberUserId = formData.get("memberUserId") as string
    const newRole = formData.get("newRole") as string

    // Base action data for returns
    const baseActionData = { action: "changeMemberRole" as const }

    // 1. Authentication & Basic Validation
    if (!user) {
      return fail(401, { ...baseActionData, error: "Unauthorized" })
    }
    if (!memberUserId || !newRole) {
      return fail(400, {
        ...baseActionData,
        error: "Missing member ID or new role.",
        failedUserId: memberUserId ?? null, // Include if available
      })
    }

    // Action data with user context for errors
    const actionDataWithError = {
      ...baseActionData,
      failedUserId: memberUserId,
    }

    // 2. Validate the submitted role
    if (!assignableRolesSet.has(newRole)) {
      return fail(400, {
        ...actionDataWithError,
        error: `Invalid role specified. Must be one of: ${ASSIGNABLE_ROLES.join(", ")}`,
      })
    }
    const validatedRole = newRole as AssignableRole

    // 3. Authorization: Verify caller is the team owner
    const { data: teamData, error: teamFetchError } = await supabase
      .from("teams")
      .select("owner_user_id")
      .eq("id", teamId)
      .single()

    if (teamFetchError || !teamData) {
      console.error(
        "Error fetching team for role change check:",
        teamFetchError,
      )
      // General error, not specific to the user being edited
      return fail(404, {
        ...baseActionData,
        error: "Team not found or could not verify ownership.",
      })
    }

    if (teamData.owner_user_id !== user.id) {
      return fail(403, {
        ...actionDataWithError,
        error: "Only the team owner can change roles.",
      })
    }

    // 4. Prevent changing the owner's role (RLS also handles this, but good check)
    if (memberUserId === teamData.owner_user_id) {
      return fail(400, {
        ...actionDataWithError,
        error: "The team owner's role cannot be changed here.",
      })
    }

    // 5. Database Operation: Update the role
    const { error: updateError } = await supabase
      .from("team_memberships")
      .update({ role: validatedRole })
      .match({ team_id: teamId, user_id: memberUserId })

    if (updateError) {
      console.error("Error changing member role:", updateError)
      // Check if it was because the user wasn't found (though unlikely if listed)
      if (updateError.code === "PGRST204") {
        // PostgREST code for no rows updated/found
        return fail(404, {
          ...actionDataWithError,
          error: "Member not found in this team.",
        })
      }
      return fail(500, {
        ...actionDataWithError,
        error: "Failed to update member role.",
      })
    }

    // 6. Success
    return {
      ...baseActionData,
      success: true,
      updatedUserId: memberUserId,
      updatedRole: validatedRole,
    }
  },

  inviteMember: async ({
    request,
    locals: { supabase, supabaseServiceRole, session },
    params,
  }) => {
    const { teamId } = params
    const user = session?.user
    const formData = await request.formData()
    const emailToInvite = formData.get("email") as string
    const roleToAssign = formData.get("role") as string

    const baseActionData = {
      action: "inviteMember" as const,
      email: emailToInvite, // Keep email for potential form repopulation
    }

    // 1. Authentication
    if (!user) {
      return fail(401, { ...baseActionData, error: "Unauthorized" })
    }

    // 2. Basic Input Validation
    if (!emailToInvite || !roleToAssign) {
      return fail(400, {
        ...baseActionData,
        error: "Email and role are required.",
      })
    }

    // 3. Email Format Validation
    const emailValidation = emailSchema.safeParse(emailToInvite)
    if (!emailValidation.success) {
      return fail(400, {
        ...baseActionData,
        error:
          emailValidation.error.errors[0]?.message ?? "Invalid email format.",
      })
    }
    const validatedEmail = emailValidation.data // Use the validated email

    // 4. Role Validation
    if (!assignableRolesSet.has(roleToAssign)) {
      return fail(400, {
        ...baseActionData,
        error: `Invalid role. Must be one of: ${ASSIGNABLE_ROLES.join(", ")}`,
      })
    }
    const validatedRole = roleToAssign as AssignableRole

    // 5. Authorization: Verify caller is the team owner
    const { data: teamData, error: teamFetchError } = await supabase
      .from("teams")
      .select("owner_user_id, name") // Fetch name for email content
      .eq("id", teamId)
      .single()

    if (teamFetchError || !teamData) {
      console.error("Error fetching team for invite check:", teamFetchError)
      return fail(404, {
        ...baseActionData,
        error: "Team not found or could not verify ownership.",
      })
    }

    // TODO: Add check for Admin role later if needed
    if (teamData.owner_user_id !== user.id) {
      return fail(403, {
        ...baseActionData,
        error: "Only the team owner can invite members.",
      })
    }

    // 6. Check if email belongs to an existing member of THIS team
    // First, find the user ID associated with the email, if any
    const { data: profileData, error: profileError } = await supabaseServiceRole
      .from("profiles")
      .select("id")
      .eq("email", validatedEmail) // Assuming email is unique in profiles
      .maybeSingle() // Use maybeSingle as they might not have a profile

    if (profileError) {
      console.error("Error fetching profile by email:", profileError)
      return fail(500, {
        ...baseActionData,
        error: "Error checking user existence.",
      })
    }

    if (profileData) {
      // User exists, now check if they are already in *this* team
      const { data: membership, error: membershipError } = await supabase
        .from("team_memberships")
        .select("user_id", { count: "exact", head: true }) // Just check existence
        .eq("team_id", teamId)
        .eq("user_id", profileData.id)

      if (membershipError) {
        console.error(
          "Error checking membership for existing user:",
          membershipError,
        )
        return fail(500, {
          ...baseActionData,
          error: "Error checking team membership.",
        })
      }

      if (membership) {
        return fail(409, {
          // 409 Conflict
          ...baseActionData,
          error: `${validatedEmail} is already a member of this team.`,
        })
      }
    }
    // If profileData is null or no membership found, proceed with invite check.

    // 7. Check for existing *pending* invitation for this email and team
    const { count: existingInviteCount, error: inviteCheckError } =
      await supabase
        .from("team_invitations")
        .select("id", { count: "exact", head: true })
        .eq("team_id", teamId)
        .eq("invited_user_email", validatedEmail)
        .eq("status", "pending")

    if (inviteCheckError) {
      console.error("Error checking existing invitations:", inviteCheckError)
      return fail(500, {
        ...baseActionData,
        error: "Could not verify existing invitations.",
      })
    }
    if (existingInviteCount && existingInviteCount > 0) {
      return fail(409, {
        // 409 Conflict
        ...baseActionData,
        error: `An invitation for ${validatedEmail} is already pending for this team.`,
      })
    }

    // 8. Generate Unique Token using Web Crypto API
    const invitationToken = crypto.randomUUID()

    // 9. Database Insert
    const inviteData: TablesInsert<"team_invitations"> = {
      team_id: teamId,
      invited_by_user_id: user.id,
      invited_user_email: validatedEmail,
      role: validatedRole,
      status: "pending",
      token: invitationToken,
    }

    const { error: insertError } = await supabase
      .from("team_invitations")
      .insert(inviteData)

    if (insertError) {
      console.error("Error inserting invitation:", insertError)
      // Check for unique constraint violation (duplicate pending invite)
      if (
        insertError.code === "23505" &&
        insertError.message.includes("unique_pending_invite")
      ) {
        // This check might be redundant due to step 7, but good fallback
        return fail(409, {
          ...baseActionData,
          error: `An invitation for ${validatedEmail} is already pending (database constraint).`,
        })
      }
      return fail(500, {
        ...baseActionData,
        error: "Failed to create invitation.",
      })
    }

    // 10. Invoke Supabase Edge Function to send email
    // Try to get the inviter's name from user metadata
    const inviterName = user.user_metadata?.full_name ?? "Someone from the team"

    // Call the edge function - Do NOT await if you want the action to return faster,
    // but handle potential background errors appropriately (logging, monitoring).
    // Awaiting is simpler for now.
    const { error: functionError } = await supabase.functions.invoke(
      "send-invite-email",
      {
        body: {
          to: validatedEmail,
          token: invitationToken,
          teamName: teamData.name,
          inviterName: inviterName,
        },
      },
    )

    // Handle email sending failure (log it, but maybe don't fail the whole action)
    if (functionError) {
      console.error(
        "Error invoking send-invite-email function:",
        functionError.message,
      )
      // Decide on action failure strategy:
      // Option 1: Fail the action entirely
      // return fail(500, { ...baseActionData, success: false, error: `Invitation created, but failed to send email: ${functionError.message}` });
      // Option 2: Return success but include a warning/note (better UX usually)
      return {
        ...baseActionData,
        success: true, // Invite WAS created
        message: `Invitation created for ${validatedEmail}, but there was an issue sending the email notification. Please contact them directly or try revoking and re-inviting.`,
        warning: "Email sending failed.", // Add a flag for the frontend if needed
        email: undefined, // Clear email field on success
      }
    }

    // 11. Return Success (if email sent successfully)
    return {
      ...baseActionData,
      success: true,
      message: `Invitation sent successfully to ${validatedEmail}.`,
      email: undefined, // Clear email on success
    }
  },

  // --- NEW: revokeInvite action ---
  revokeInvite: async ({ request, locals: { supabase, session }, params }) => {
    const { teamId } = params
    const user = session?.user
    const formData = await request.formData()
    const invitationId = formData.get("invitationId") as string

    const baseActionData = {
      action: "revokeInvite" as const,
      failedInviteId: invitationId, // Track which one failed if needed
    }

    // 1. Authentication
    if (!user) {
      return fail(401, { ...baseActionData, error: "Unauthorized" })
    }

    // 2. Basic Input Validation
    if (!invitationId) {
      return fail(400, {
        ...baseActionData,
        error: "Invitation ID missing.",
        failedInviteId: null,
      })
    }

    // 3. Authorization: Verify caller is the team owner
    //    (Could also allow Admin in the future)
    const { data: teamData, error: teamFetchError } = await supabase
      .from("teams")
      .select("owner_user_id")
      .eq("id", teamId)
      .single()

    if (teamFetchError || !teamData) {
      console.error("Error fetching team for revoke check:", teamFetchError)
      return fail(404, {
        ...baseActionData,
        error: "Team not found or could not verify ownership.",
      })
    }

    if (teamData.owner_user_id !== user.id) {
      return fail(403, {
        ...baseActionData,
        error: "Only the team owner can revoke invitations.",
      })
    }

    // 4. Database Operation: Delete the invitation
    //    We delete it directly rather than changing status to 'revoked'
    //    Ensure we only delete PENDING invites for this team
    const { error: deleteError } = await supabase
      .from("team_invitations")
      .delete()
      .match({ id: invitationId, team_id: teamId, status: "pending" }) // Match all 3 for safety

    if (deleteError) {
      console.error("Error revoking invitation:", deleteError)
      return fail(500, {
        ...baseActionData,
        error: "Failed to revoke invitation.",
      })
    }

    // If the delete operation affected 0 rows (e.g., invite wasn't pending or didn't exist for this team)
    // It's generally okay, the result is the invite is gone. We could check the count if needed.
    // const { count } = await ...delete()...
    // if (count === 0) return fail(404, {...})

    // 5. Success
    return {
      ...baseActionData,
      success: true,
      message: "Invitation revoked successfully.",
      failedInviteId: undefined, // Clear on success
    }
  },
}
